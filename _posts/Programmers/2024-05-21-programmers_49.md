---
layout: post
title: 프로그래머스 LV1 "이진 변환 반복하기"
date: 2024-05-21 11:58 +0900
description: 
image: ../assets/img/programmers_logo.png
category: [programmers, Lv2]
tags: code lv2 programmers javascript
published: true
sitemap: true
---

# 프로그래머스 LV1 이진 변환 반복하기

  기초부터 다시 공부를 하기위해 [프로그래머스](https://programmers.co.kr/) 라는 사이트에서
  코딩테스트를 LV0 부터 가능한곳까지 못하는곳은 레퍼런스를 찾아가며 풀어보려고 합니다.

  매일 1개의 풀이를 하고 그 풀이에대한 나의 생각 및 해석을 적어보려합니다.

  오늘은 LV2 문제 '이진 변환 반복하기' 문제입니다.

  ![프로그래머스 이미지](/assets/img//post49_01.png)

  위 이미지가 프로그래머스 코딩문제입니다.
  
  문제는 0과 1로 이루어진 문자열 `s`를 매개변수 입력받아, `s`가 "1"이 될 때까지 계속해서 `s`에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 출력하는 문제입니다.

  그럼 오늘의 문제를 한번 풀어보겠습니다.

  기본 세팅 코드도 알아보겠습니다.

```javascript
function solution(s) {
  var answer = [];
  return answer;
}
```

기본 세팅 코드는 매개변수 `s`가 입력되고 함수 안에는 `answer`이라는 변수가 선언되어 리턴하는 간단한 기본 세팅 코드입니다.

오늘 문제의 핵심을 간단하게 문제를 풀어보면

1. `s`가 "1"이 될 때까지 반복합니다.

2. 문자열 `s`에서 모든 0을 제거합니다.

3. 제거 후 남은 문자열의 길이를 구합니다.

4. 그 길이를 2진법으로 변환하여 `s`에 저장합니다.

5. 이진 변환의 횟수와 제거된 0의 총 개수를 기록합니다.

위 순서가 오늘 문제의 핵심입니다.

문제를 풀기 전에 이진수가 무엇인지 한번 간단하게 설명드리고 문제를 풀어보겠습니다.

## 이진법

이진법(二進法, Binary)은 컴퓨터 과학에서 사용되는 수 체계로, 두 개의 숫자 0과 1만을 사용하여 모든 숫자를 표현합니다. 이는 디지털 전자 장치와 컴퓨터 시스템에서 기본적으로 사용되는 시스템입니다. 왜냐하면 이진법은 전기적 신호의 상태 (켜짐/꺼짐, 참/거짓)와 잘 맞아떨어지기 때문입니다.

이진법에서 각 자리는 2의 거듭제곱을 의미합니다. 예를 들어, 이진수 1011은 다음과 같이 해석할 수 있습니다:
```scss
1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0
= 1 * 8 + 0 * 4 + 1 * 2 + 1 * 1
= 8 + 0 + 2 + 1
= 11 (십진수)
```

즉, 이진수 1011은 십진수로 11을 나타냅니다.

다음은 몇 가지 이진수와 그에 해당하는 십진수 예시입니다:

| 이진수	| 십진수|
|--------|-------|
| 0000	 | 0     |
| 0001	 | 1     |
| 0010	 | 2     |
| 0011	 | 3     |
| 0100	 | 4     |
| 0101	 | 5     |
| 0110	 | 6     |
| 0111	 | 7     |
| 1000	 | 8     |
| 1001	 | 9     |
| 1010	 | 10    |

이진법의 기본 원리는 다음과 같습니다:

- 각 자릿수는 0 또는 1일 수 있습니다.
- 오른쪽에서 왼쪽으로 각 자리는 2의 거듭제곱을 나타냅니다 (2^0, 2^1, 2^2, 2^3, ...).
- 각 자리의 값을 더하여 십진수를 얻습니다.

이진법은 컴퓨터가 데이터를 처리하고 저장하는 데 매우 유용하며, 모든 현대 컴퓨터 시스템의 기본입니다.

이렇게 간단하게 이진법에 대해서 한번 알아보았습니다.

그럼 오늘 문제의 풀이를 코드로 한번 작성해 보겠습니다.

```javascript
function solution(s) {
  let count = 0;
  let zeroCount = 0;

  while (s !== "1") {
    let originalLength = s.length;
    s = s.replace(/0/g, '');
    let newLength = s.length;
    zeroCount += (originalLength - newLength);
    s = newLength.toString(2);
    count++;
  }
  return [count, zeroCount];
}
```
위 코드의 간단한 설명을 알려드리겠습니다.

1. **초기화**: `count`와 `zeroCount`를 0으로 초기화합니다.
   - `count`는 이진 변환의 횟수를 기록합니다.
   - `zeroCount`는 제거된 0의 총 개수를 기록합니다.

2. **반복문**: `s`가 "1"이 될 때까지 반복합니다.
   - `originalLength`에 현재 문자열 `s`의 길이를 저장합니다.
   - `s.replace(/0/g, '')`로 문자열 `s`에서 모든 0을 제거합니다.
   - `newLength`에 0을 제거한 후의 문자열 길이를 저장합니다.
   - 제거된 0의 개수를 `zeroCount`에 누적합니다.
   - 새로운 문자열 길이 `newLength`를 2진법으로 변환하여 `s`에 저장합니다.
   - 이진 변환 횟수를 증가시킵니다.

3. **반환**: 이진 변환의 총 횟수와 제거된 0의 총 개수를 배열 `[count, zeroCount]`로 반환합니다.

이 코드를 통해 주어진 문자열 `s`에 대해 이진 변환을 반복적으로 수행하여 최종적으로 "1"이 될 때까지의 변환 횟수와 제거된 0의 개수를 계산할 수 있습니다.

![프로그래머스 이미지](/assets/img//post49_02.png)

성공이네요!

오늘은 [프로그래머스](https://programmers.co.kr/) LV2 '이진 변환 반복하기' 문제의 대해서 알아봤습니다.

제 방법이 꼭 정답은 아니니 그저 이런방법도 있구나하고 참고용으로만 봐주시면 감사하겠습니다.

감사합니다.